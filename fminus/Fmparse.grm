%{
(* Put util functions here. *)
open Fmabsyn;

(* structure As = Fmabsyn; *)
(*
fun mkintop2 opr (Int n1, Int n2)  = Int (opr (n1, n2))
fun mkboolop2 opr (Int n1, Int n2) = Int (opr (n1, n2))
fun mkrelop2 opr (Int n1, Int n2)  = Int (if opr (n1, n2) then 1 else 0)

val lor  : int * int -> int = op *
val land : int * int -> int = op +
val lneg = fn b => if b = 0 then 1 else 0 *)
%}

%token <int> INT
%token <string> NAME
%token PLUS MINUS TIMES DIV MOD BITAND BITOR XOR
%token EQ NE LT LE GE GT
%token ASSIGN COLON COMMA DASHARROW SEMI 
%token INTTYPE BOOLTYPE
%token AND OR NOT
%token TRUE FALSE
%token ELSE IF IMPORT MAIN PROC PRINT RETURN THEN VAR WHILE
%token LBRACE RBRACE LPAR RPAR LSQUARE RSQUARE
%token EOF
%token JUNK

%left OR /* lowest precedence */
%left AND
%nonassoc EQ NE LT LE GE GT
%left BITOR	
%left XOR		
%left BITAND
%left PLUS MINUS 
%left TIMES DIV MOD        	/* highest precedence  */

%start Main
%type <Fmabsyn.progtext> Main Ptext 
%type <Fmabsyn.symtable> Vdecls 
%type <Fmabsyn.fdecl list> Fdecls 
%type <(Fmabsyn.symtable * Fmabsyn.stmt list)> Sblock
%type <Fmabsyn.stmt list> Stmts
%type <Fmabsyn.symtable>  Params 
%type <Fmabsyn.expr list> Args
%type <(string * Fmabsyn.valtype)> Vdecl Param
%type <Fmabsyn.fdecl> Fdecl 
%type <Fmabsyn.stmt> Stmt AssnStmt IfStmt WhileStmt PrintStmt CallStmt
%type <Fmabsyn.valtype> Typeexp Ftype 
%type <Fmabsyn.expr> Expr VarExpr RelExpr AssocExpr
/*
%type <Fmabsyn.sourceexpr> Main Ptext Expr SExpr AppExpr AExpr
%type <Fmabsyn.sourceexpr list> Exprs
%type <string * Fmabsyn.sourceexpr> Defn
%type <(string * Fmabsyn.sourceexpr) list> Defns
%type <int * string list * Fmabsyn.sourceexpr> Alt
%type <(int * string list * Fmabsyn.sourceexpr) list> Alts
%type <string list> Vars 
*/
%%

Main:
    // Compunit EOF
    Ptext EOF                            { $1 } 
;

/* Compunit: 
    Imports Ptext                       { } // later
; */

/* Imports:
                            { [ ] } // recursively include parse trees?
;
*/

Ptext:
    Vdecls Fdecls                       { {gdecls=$1, fdecls=$2, main=NONE} }
  | Vdecls Fdecls MAIN Sblock           { {gdecls=$1, fdecls=$2, 
                                           main=(SOME $4)} }
;
Vdecls:
    /* empty */                         { [] }
  | Vdecl SEMI Vdecls                   { $1 :: $3 }
;
Vdecl: 
    VAR NAME COLON Typeexp              { ($2, $4) }
;
Typeexp: 
    INTTYPE                             { Int }
  | BOOLTYPE                            { Bool }
;
Fdecls:
    /* empty */                         { [] }
  | Fdecl Fdecls                        { $1 :: $2 }
;
Fdecl: 
  PROC NAME LPAR Params RPAR Ftype Sblock { {fname=$2, rettype=$6,  ldecls=(#1 $7), stmts=(#2 $7)} }
;
Params: 
    /* empty */                         { [] }
  | Param                               { [$1] }
  | Param COMMA Params                  { $1 :: $3 }
;
Param: 
  NAME COLON Typeexp                    { ($1, $3) }
;
Ftype: 
    /* empty */                         { Unit }
  | DASHARROW Typeexp                   { $2 }
;
Sblock: 
    LBRACE Vdecls Stmts RBRACE          { ($2, $3) }
;
Stmts: 
    /* empty */                         { [] }
  | Stmt SEMI Stmts                     { $1 :: $3 }
;
Stmt: 
    AssnStmt                            { $1 }
//  | ForStmt                           { $1 }
  | WhileStmt                           { $1 }
  | IfStmt                              { $1 }
  | PrintStmt                           { $1 }
  | CallStmt                            { $1 }
;
AssnStmt:
    NAME ASSIGN Expr                    { AssignStmt ($1, $3) }
;
//ForStmt:
//    FOR 
WhileStmt:
    WHILE LPAR Expr RPAR Sblock         { Fmabsyn.WhileStmt ($3, $5) }
;
IfStmt:
    IF LPAR Expr RPAR Sblock                   { IfStmt ($3, $5, NONE) }
  | IF LPAR Expr RPAR Sblock ELSE Sblock       { IfStmt ($3, $5, SOME $7) }
;
PrintStmt:
    PRINT Expr                          { PrintStmt $2 }
;
CallStmt:
    NAME LPAR Args RPAR                 { CallStmt ($1, $3) }
;
// Encode expression type at syntax level?
Args: 
    /* empty */                         { [] }
  | Expr                                { [$1] }     // Allows the dangling comma
  | Expr COMMA Args                     { $1 :: $3 } // what if a non-var used to call a fun?
;

Expr:
    AssocExpr                            { $1 }
  | RelExpr                              { $1 }
// | StringExpr
;

VarExpr: 
    NAME                                { VarExpr $1 }
;
// if an expression is a variable you can't tell if its bool or num.
// so don't encode types at all
RelExpr:
    AssocExpr EQ AssocExpr              { RelExpr (Fmabsyn.Eq, $1, $3) }
  | AssocExpr NE AssocExpr              { RelExpr (Fmabsyn.Ne, $1, $3) }
  | AssocExpr LT AssocExpr              { RelExpr (Fmabsyn.Lt, $1, $3) }
  | AssocExpr LE AssocExpr              { RelExpr (Fmabsyn.Le, $1, $3) }
  | AssocExpr GT AssocExpr              { RelExpr (Fmabsyn.Gt, $1, $3) }
  | AssocExpr GE AssocExpr              { RelExpr (Fmabsyn.Ge, $1, $3) }
;
AssocExpr:
   INT                                  { ConstExpr $1 }
  | VarExpr                             { $1 }
  | LPAR AssocExpr RPAR                 { $2 }
  | IF LPAR AssocExpr RPAR THEN AssocExpr ELSE AssocExpr { Fmabsyn.IfExpr ($3, $6, $8) }
  | AssocExpr DIV AssocExpr                     { ArithExpr (Fmabsyn.Div, $1, $3) }
  | AssocExpr MOD AssocExpr                     { ArithExpr (Fmabsyn.Mod, $1, $3) }
  | AssocExpr TIMES AssocExpr                   { ArithExpr (Fmabsyn.Times, $1, $3) }
  | AssocExpr PLUS AssocExpr                    { ArithExpr (Fmabsyn.Plus, $1, $3) }
  | AssocExpr MINUS AssocExpr                   { ArithExpr (Fmabsyn.Minus, $1, $3) }
  | AssocExpr XOR AssocExpr                     { ArithExpr (Fmabsyn.Xor, $1, $3) }
  | AssocExpr BITOR AssocExpr                   { ArithExpr (Fmabsyn.Bitor, $1, $3) }
  | AssocExpr BITAND AssocExpr                  { ArithExpr (Fmabsyn.Bitand, $1, $3) }
  | TRUE                                        { ConstBool true }
  | FALSE                                       { ConstBool false }
  | NOT AssocExpr                               { NotExpr $2 }
  | AssocExpr AND AssocExpr                     { BoolExpr (And, $1, $3) }
  | AssocExpr OR AssocExpr                      { BoolExpr (Or, $1, $3) }
;
// StringExpr
