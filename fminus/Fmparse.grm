%{
(* Put util functions here. *)
open Fmabsyn;

(** Add a single storage type to every entry of a var list,
  * making it a symbol table *)
fun addstoretype _ [] = []
  | addstoretype sclass ((name, vtype)::ents) = 
    {name=name, vtype=vtype, sclass=sclass}::(addstoretype sclass ents)
;
(*
fun mkintop2 opr (Int n1, Int n2)  = Int (opr (n1, n2))
fun mkboolop2 opr (Int n1, Int n2) = Int (opr (n1, n2))
fun mkrelop2 opr (Int n1, Int n2)  = Int (if opr (n1, n2) then 1 else 0)

val lor  : int * int -> int = op *
val land : int * int -> int = op +
val lneg = fn b => if b = 0 then 1 else 0 *)
%}
/* Should have location (line, offset) pairs for everything? */
%token <int> INT
%token <string> NAME
%token PLUS MINUS TIMES DIV MOD BITAND BITOR XOR LSHIFT RSHIFT
%token EQ NE LT LE GE GT
%token ASSIGN COLON COMMA DASHARROW SEMI 
%token INTTYPE BOOLTYPE
%token INDATA OUTDATA
%token AND OR NOT
%token TRUE FALSE
%token <Fmabsyn.srcpos> BREAK
%token ELSE FOR IF IMPORT MAIN PROC PRINT RETURN THEN VAR WHILE
%token LBRACE RBRACE LPAR RPAR LSQUARE RSQUARE
%token EOF
%token JUNK

%left OR /* lowest precedence */
%left AND
%nonassoc EQ NE LT LE GE GT
%left BITOR
%left XOR
%left BITAND
%left LSHIFT RSHIFT
%left PLUS MINUS
%left TIMES DIV MOD /* highest precedence  */

%start Main
%type <Fmabsyn.progtext> Main Ptext
%type <Fmabsyn.symtable> Ddecls
/* Vdecls isn't symtable because store class added at higher level */
%type <(string * Fmabsyn.valtype) list> Vdecls Vdecl 
%type <string list> Varlist
%type <Fmabsyn.fdefn list> Fdefns 
%type <(Fmabsyn.symtable * Fmabsyn.stmt list)> Sblock
%type <(string * Fmabsyn.valtype) list>  Params 
%type <Fmabsyn.expr list> Args
%type <(string * Fmabsyn.valtype)>Param
%type <Fmabsyn.symentry> Ddecl
%type <Fmabsyn.fdefn> Fdefn
%type <Fmabsyn.stmt list> Stmts
%type <Fmabsyn.stmt> Stmt LineStmt BlockStmt
%type <Fmabsyn.stmt> AssnStmt IfStmt WhileStmt PrintStmt CallStmt
%type <Fmabsyn.stmt> ReturnStmt BreakStmt ForStmt
%type <Fmabsyn.valtype> Typeexp Ftype 
%type <Fmabsyn.expr> Expr VarExpr RelExpr AssocExpr
%%

Main:
    // Compunit EOF
    Ptext EOF                            { $1 } 
;

/* Compunit: 
    Imports Ptext                       { } // later
; */

/* Imports:
                            { [ ] } // recursively include parse trees?
;
*/

Ptext:
    Ddecls Vdecls Fdefns                { {ddecls=$1,
                                           gdecls=(addstoretype Global $2), 
                                           fdefns=$3, main=NONE} }
  | Ddecls Vdecls Fdefns MAIN Sblock    { {ddecls=$1,
                                           gdecls=(addstoretype Global $2), 
                                           fdefns=$3, main=(SOME $5)} }
;
Ddecls:
    /* empty */                         { [] }
  | Ddecl SEMI Ddecls                   { $1 :: $3 }
;
Ddecl:
    INDATA NAME COLON Typeexp             { {name=$2, vtype=$4, sclass=Indata} }
  | OUTDATA NAME COLON Typeexp            { {name=$2, vtype=$4, sclass=Outdata} }
;
Vdecls:
    /* empty */                         { [] }
  | Vdecl SEMI Vdecls                   { $1 @ $3 }
;
Vdecl: 
    VAR Varlist COLON Typeexp              { map (fn v => (v, $4)) $2 }
;
Varlist:
    NAME                                 { [$1] }
  | Varlist COMMA NAME                   { $1 @ [$3] }
;
Typeexp: 
    INTTYPE                             { FmInt }
  | BOOLTYPE                            { FmBool }
;
Fdefns:
    /* empty */                         { [] }
  | Fdefn Fdefns                        { $1 :: $2 }
;
Fdefn: 
  PROC NAME LPAR Params RPAR Ftype Sblock { ({fname=$2, argdecls=(addstoretype Arg $4), 
                                              rettype=$6}, $7) }
;
Params: 
    /* empty */                         { [] }
  | Param                               { [$1] }
  | Param COMMA Params                  { $1 :: $3 }
;
Param: 
  NAME COLON Typeexp                    { ($1, $3) }
;
Ftype: 
    /* empty */                         { FmUnit }
  | DASHARROW Typeexp                   { $2 }
;
Sblock: 
    LBRACE Vdecls Stmts RBRACE          { ((addstoretype Local $2), $3) }
;
Stmts: 
    /* empty */                         { [] }
  | Stmt Stmts                          { $1 :: $2 }
;
Stmt:
    LineStmt SEMI                       { $1 }
  | BlockStmt                           { $1 }
;
LineStmt:      
    AssnStmt                            { $1 }
  | PrintStmt                           { $1 }
  | CallStmt                            { $1 }
  | ReturnStmt                          { $1 }
  | BreakStmt                           { $1 }
;
BlockStmt:
  | ForStmt                             { $1 }
  | WhileStmt                           { $1 }
  | IfStmt                              { $1 }
;
AssnStmt:
    NAME ASSIGN Expr                    { AssignStmt ($1, $3) }
;
ForStmt: 
    FOR LPAR AssnStmt SEMI Expr SEMI AssnStmt RPAR Sblock   { ForStmt ($3, $5, $7, $9) }
;
WhileStmt:
    WHILE LPAR Expr RPAR Sblock         { WhileStmt ($3, $5) }
;
IfStmt:
    IF LPAR Expr RPAR Sblock                   { IfStmt ($3, $5, NONE) }
  | IF LPAR Expr RPAR Sblock ELSE Sblock       { IfStmt ($3, $5, SOME $7) }
;
PrintStmt:
    PRINT Expr                          { PrintStmt $2 }
;
CallStmt:
    NAME LPAR Args RPAR                 { CallStmt ($1, $3) }
;
ReturnStmt:
    RETURN Expr                         { ReturnStmt (SOME $2) }
  | RETURN                              { ReturnStmt NONE }   
;
BreakStmt:
    BREAK                               { BreakStmt {pos=$1} }
;
// Encode expression type at syntax level?
Args: 
    /* empty */                         { [] }
  | Expr                                { [$1] }     // Allows dangling comma
  | Expr COMMA Args                     { $1 :: $3 } // OK if a non-var used to call a fun?
;

Expr:
    AssocExpr                            { $1 }
  | RelExpr                              { $1 }
  | LPAR Expr RPAR                       { $2 }
// | StringExpr
;

VarExpr: 
    NAME                                { VarExpr $1 }
;
// All RelExprs have type bool, but AssocExprs can have type bool also.
RelExpr:
    AssocExpr EQ AssocExpr                      { CompExpr (Eq, $1, $3) }
  | AssocExpr NE AssocExpr                      { CompExpr (Ne, $1, $3) }
  | AssocExpr LT AssocExpr                      { CompExpr (Lt, $1, $3) }
  | AssocExpr LE AssocExpr                      { CompExpr (Le, $1, $3) }
  | AssocExpr GT AssocExpr                      { CompExpr (Gt, $1, $3) }
  | AssocExpr GE AssocExpr                      { CompExpr (Ge, $1, $3) }
  | NOT RelExpr                                 { NotExpr $2 }
  | RelExpr AND RelExpr                         { BoolExpr (And, $1, $3) }
  | RelExpr OR RelExpr                          { BoolExpr (Or, $1, $3) }
;
AssocExpr:
    INT                                         { ConstExpr $1 }
  | TRUE                                        { ConstBool true }
  | FALSE                                       { ConstBool false }
  | VarExpr                                     { $1 }
  | IF LPAR AssocExpr RPAR THEN AssocExpr ELSE AssocExpr { IfExpr ($3, $6, $8) }
  | AssocExpr DIV AssocExpr                     { ArithExpr (Div, $1, $3) }
  | AssocExpr MOD AssocExpr                     { ArithExpr (Mod, $1, $3) }
  | AssocExpr TIMES AssocExpr                   { ArithExpr (Times, $1, $3) }
  | AssocExpr PLUS AssocExpr                    { ArithExpr (Plus, $1, $3) }
  | AssocExpr MINUS AssocExpr                   { ArithExpr (Minus, $1, $3) }
  | AssocExpr XOR AssocExpr                     { ArithExpr (Xor, $1, $3) }
  | AssocExpr BITOR AssocExpr                   { ArithExpr (Bitor, $1, $3) }
  | AssocExpr BITAND AssocExpr                  { ArithExpr (Bitand, $1, $3) }
  | NAME LPAR Args RPAR                         { FunCallExpr ($1, $3) }
;
// StringExpr // for concatenation and such. 
