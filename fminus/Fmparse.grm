%{
(* Put util functions here. *)
open Fmabsyn;

(* structure As = Fmabsyn; *)
(*
fun mkintop2 opr (Int n1, Int n2)  = Int (opr (n1, n2))
fun mkboolop2 opr (Int n1, Int n2) = Int (opr (n1, n2))
fun mkrelop2 opr (Int n1, Int n2)  = Int (if opr (n1, n2) then 1 else 0)

val lor  : int * int -> int = op *
val land : int * int -> int = op +
val lneg = fn b => if b = 0 then 1 else 0 *)
%}

%token <int> INT
%token <string> NAME
%token PLUS MINUS TIMES DIV MOD BITAND BITOR XOR
%token EQ NE LT LE GE GT
%token ASSIGN COLON COMMA DASHARROW SEMI 
%token INTTYPE BOOLTYPE
%token AND OR NOT
%token TRUE FALSE
%token ELSE IF IMPORT MAIN PROC PRINT RETURN THEN VAR WHILE
%token LBRACE RBRACE LPAR RPAR LSQUARE RSQUARE
%token EOF
%token JUNK

%left OR /* lowest precedence */
%left AND
%nonassoc EQ NE LT LE GE GT
%left BITOR	
%left XOR		
%left BITAND
%left PLUS MINUS 
%left TIMES DIV MOD        	/* highest precedence  */

%start Main
%type <Fmabsyn.progtext> Main Ptext 
%type <Fmabsyn.symtable> Vdecls 
%type <Fmabsyn.fdefn list> Fdefns 
%type <(Fmabsyn.symtable * Fmabsyn.stmt list)> Sblock
%type <Fmabsyn.stmt list> Stmts
%type <Fmabsyn.symtable>  Params 
%type <Fmabsyn.expr list> Args
%type <(string * Fmabsyn.valtype)> Vdecl Param
%type <Fmabsyn.fdefn> Fdefn
%type <Fmabsyn.stmt> Stmt AssnStmt IfStmt WhileStmt PrintStmt CallStmt ReturnStmt
%type <Fmabsyn.valtype> Typeexp Ftype 
%type <Fmabsyn.expr> Expr VarExpr RelExpr AssocExpr
/*
%type <Fmabsyn.sourceexpr> Main Ptext Expr SExpr AppExpr AExpr
%type <Fmabsyn.sourceexpr list> Exprs
%type <string * Fmabsyn.sourceexpr> Defn
%type <(string * Fmabsyn.sourceexpr) list> Defns
%type <int * string list * Fmabsyn.sourceexpr> Alt
%type <(int * string list * Fmabsyn.sourceexpr) list> Alts
%type <string list> Vars 
*/
%%

Main:
    // Compunit EOF
    Ptext EOF                            { $1 } 
;

/* Compunit: 
    Imports Ptext                       { } // later
; */

/* Imports:
                            { [ ] } // recursively include parse trees?
;
*/

Ptext:
    Vdecls Fdefns                       { {gdecls=$1, fdefns=$2, main=NONE} }
  | Vdecls Fdefns MAIN Sblock           { {gdecls=$1, fdefns=$2, 
                                           main=(SOME $4)} }
;
Vdecls:
    /* empty */                         { [] }
  | Vdecl SEMI Vdecls                   { $1 :: $3 }
;
Vdecl: 
    VAR NAME COLON Typeexp              { ($2, $4) }
;
Typeexp: 
    INTTYPE                             { FmInt }
  | BOOLTYPE                            { FmBool }
;
Fdefns:
    /* empty */                         { [] }
  | Fdefn Fdefns                        { $1 :: $2 }
;
Fdefn: 
  PROC NAME LPAR Params RPAR Ftype Sblock { ({fname=$2, argdecls=$4, 
                                              rettype=$6}, $7) }
;
Params: 
    /* empty */                         { [] }
  | Param                               { [$1] }
  | Param COMMA Params                  { $1 :: $3 }
;
Param: 
  NAME COLON Typeexp                    { ($1, $3) }
;
Ftype: 
    /* empty */                         { FmUnit }
  | DASHARROW Typeexp                   { $2 }
;
Sblock: 
    LBRACE Vdecls Stmts RBRACE          { ($2, $3) }
;
Stmts: 
    /* empty */                         { [] }
  | Stmt SEMI Stmts                     { $1 :: $3 }
;
Stmt: 
    AssnStmt                            { $1 }
//  | ForStmt                           { $1 }
  | WhileStmt                           { $1 }
  | IfStmt                              { $1 }
  | PrintStmt                           { $1 }
  | CallStmt                            { $1 }
  | ReturnStmt                          { $1 }
;
AssnStmt:
    NAME ASSIGN Expr                    { AssignStmt ($1, $3) }
;
//ForStmt:
//    FOR 
WhileStmt:
    WHILE LPAR Expr RPAR Sblock         { Fmabsyn.WhileStmt ($3, $5) }
;
IfStmt:
    IF LPAR Expr RPAR Sblock                   { IfStmt ($3, $5, NONE) }
  | IF LPAR Expr RPAR Sblock ELSE Sblock       { IfStmt ($3, $5, SOME $7) }
;
PrintStmt:
    PRINT Expr                          { PrintStmt $2 }
;
CallStmt:
    NAME LPAR Args RPAR                 { CallStmt ($1, $3) }
;
ReturnStmt:
    RETURN Expr                         { ReturnStmt $2 }
;
// Encode expression type at syntax level?
Args: 
    /* empty */                         { [] }
  | Expr                                { [$1] }     // Allows the dangling comma
  | Expr COMMA Args                     { $1 :: $3 } // what if a non-var used to call a fun?
;

Expr:
    AssocExpr                            { $1 }
  | RelExpr                              { $1 }
  | LPAR Expr RPAR                       { $2 }
// | StringExpr
;

VarExpr: 
    NAME                                { VarExpr $1 }
;
// All RelExprs have type bool, but AssocExprs can have type bool also.
RelExpr:
    AssocExpr EQ AssocExpr                      { CompExpr (Eq, $1, $3) }
  | AssocExpr NE AssocExpr                      { CompExpr (Ne, $1, $3) }
  | AssocExpr LT AssocExpr                      { CompExpr (Lt, $1, $3) }
  | AssocExpr LE AssocExpr                      { CompExpr (Le, $1, $3) }
  | AssocExpr GT AssocExpr                      { CompExpr (Gt, $1, $3) }
  | AssocExpr GE AssocExpr                      { CompExpr (Ge, $1, $3) }
  | NOT RelExpr                                 { NotExpr $2 }
  | RelExpr AND RelExpr                         { BoolExpr (And, $1, $3) }
  | RelExpr OR RelExpr                          { BoolExpr (Or, $1, $3) }
;
AssocExpr:
    INT                                         { ConstExpr $1 }
  | TRUE                                        { ConstBool true }
  | FALSE                                       { ConstBool false }
  | VarExpr                                     { $1 }
  | IF LPAR AssocExpr RPAR THEN AssocExpr ELSE AssocExpr { IfExpr ($3, $6, $8) }
  | AssocExpr DIV AssocExpr                     { ArithExpr (Div, $1, $3) }
  | AssocExpr MOD AssocExpr                     { ArithExpr (Mod, $1, $3) }
  | AssocExpr TIMES AssocExpr                   { ArithExpr (Times, $1, $3) }
  | AssocExpr PLUS AssocExpr                    { ArithExpr (Plus, $1, $3) }
  | AssocExpr MINUS AssocExpr                   { ArithExpr (Minus, $1, $3) }
  | AssocExpr XOR AssocExpr                     { ArithExpr (Xor, $1, $3) }
  | AssocExpr BITOR AssocExpr                   { ArithExpr (Bitor, $1, $3) }
  | AssocExpr BITAND AssocExpr                  { ArithExpr (Bitand, $1, $3) }
  | NAME LPAR Args RPAR                         { FunCallExpr ($1, $3) }
;
// StringExpr
