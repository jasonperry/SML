# Makefile for fminus; based on 'lexyacc' and 'units' examples

MOSMLHOME=/usr/share/mosml
MOSMLTOOLS=camlrunm $(MOSMLHOME)/tools
MOSMLC=mosmlc -c
MOSMLL=mosmlc	 # linker command
MOSMLLEX=mosmllex
MOSMLYACC=mosmlyac

#UNITS= -structure Fmparse Fmtypes Fmlexer Fmabsyn -toplevel Symtable Pmain

all: Either.uo Symtable.uo Fmabsyn.uo Fmlexer.uo Fmparse.uo Fmtypes.uo Pmain.uo fmc
#	mosml load

.SUFFIXES :
.SUFFIXES : .sml .sig .ui .uo .mlp .lex .c .o

# general rules for converting files with one extension to another. 
.sig.ui:
	$(MOSMLC) $<

# this one needs to be in toplevel mode
#Symtable.uo: Symtable.sml
#	$(MOSMLC) -toplevel Symtable.sml

# these rules are only needed if UNITS is undefined or empty
#.sml.uo:
#	$(MOSMLC) $<
#
#.lex.sml:
#	$(MOSMLLEX) $<
# Generated by hand! I know whut I'm doin!
Either.uo: Either.sml
	$(MOSMLC) -structure Either.sml

Symtable.uo: Symtable.sml 
	$(MOSMLC) -toplevel Symtable.sml 

Fmabsyn.uo: Fmabsyn.sml Symtable.uo # if uo changed, ui definitely did.
	$(MOSMLC) -toplevel Symtable.ui Fmabsyn.sml 

Fmparse.sml Fmparse.sig: Fmparse.grm
	$(MOSMLYACC) Fmparse.grm

Fmparse.ui: Fmparse.sig Fmabsyn.uo Symtable.uo
	$(MOSMLC) -structure Symtable.ui Fmabsyn.ui Fmparse.sig 

# wait, what's parser/lexer dependency? First ui, then uo
Fmlexer.uo: Fmlexer.sml 
	$(MOSMLC) -structure Fmparse.ui Fmlexer.sml 

Fmparse.uo: Fmparse.sml Fmparse.ui 
	$(MOSMLC) -structure Symtable.ui Fmabsyn.ui Fmparse.sml 

Fmtypes.uo: Fmtypes.sml Symtable.uo Either.uo Fmabsyn.uo
	$(MOSMLC) -structure Symtable.ui Either.ui Fmabsyn.ui Fmtypes.sml 

Pmain.uo: Pmain.sml Symtable.uo Fmabsyn.uo Fmparse.uo Fmlexer.uo
	$(MOSMLC) -toplevel Symtable.ui Fmabsyn.ui Fmlexer.ui \
    Fmtypes.ui Fmparse.ui Pmain.sml 

fmc:	Pmain.uo
	$(MOSMLL) -o fmc Pmain.uo

#depend: # Fmlexer.sml Fmparse.sml 
#	rm -f Makefile.bak
#	mv Makefile Makefile.bak
#	$(MOSMLTOOLS)/cutdeps < Makefile.bak > Makefile
#	$(MOSMLTOOLS)/mosmldep $(UNITS) >> Makefile

clean:
	rm -f Fmparse.sig Fmparse.sml Fmlexer.sml
	rm -f *.ui *.uo
	rm -f fmc
	rm -f Makefile.bak

